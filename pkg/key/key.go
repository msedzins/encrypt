package key

import (
	"crypto/rand"
	"errors"
	"io"

	"github.com/awnumar/memguard"
)

type Key struct {
	key *memguard.LockedBuffer
}

type KeySize int

const (
	// AES-128
	KeySize128 KeySize = 16
	// AES-192
	KeySize192 KeySize = 24
	// AES-256
	KeySize256 KeySize = 32
)

var (
	ErrInvalidKeySize = errors.New("invalid key size")
)

func (k KeySize) IsValid() bool {
	return k == KeySize128 || k == KeySize192 || k == KeySize256
}

// NewKeyFromBytes creates a new Key using the provided byte slice
// The bytes will be copied into secure memory
func NewKeyFromBytes(keyBytes []byte) (*Key, error) {
	// Validate key size by converting byte length to KeySize
	keySize := KeySize(len(keyBytes))
	if !keySize.IsValid() {
		return nil, ErrInvalidKeySize
	}

	// Create protected memory buffer from the provided bytes
	buffer := memguard.NewBufferFromBytes(keyBytes)

	return &Key{key: buffer}, nil
}

// NewKey creates and returns a new Key with randomly generated bytes
func NewKey(size KeySize) (*Key, error) {
	if !size.IsValid() {
		return nil, ErrInvalidKeySize
	}

	// Generate random bytes
	randomBytes := make([]byte, size)
	if _, err := io.ReadFull(rand.Reader, randomBytes); err != nil {
		return nil, err
	}

	// Create protected memory buffer
	buffer := memguard.NewBufferFromBytes(randomBytes)

	return &Key{key: buffer}, nil
}

// Destroy securely wipes the key from memory
// Call this with defer when you're done with the key
func (k *Key) Destroy() {
	if k != nil && k.key != nil {
		k.key.Destroy()
		k.key = nil // Clear the reference to prevent reuse
	}
}

// Bytes returns the key bytes for use in encryption/decryption
// Be careful with the returned slice as it contains sensitive data
func (k *Key) Bytes() []byte {
	if k == nil || k.key == nil {
		return nil
	}
	return k.key.Bytes()
}
